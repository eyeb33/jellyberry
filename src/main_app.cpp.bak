#include <Arduino.h>
#include <WiFi.h>
#include <WebSocketsClient.h>
#include <ArduinoJson.h>
#include <FastLED.h>
#include <driver/i2s.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include "Config.h"

// ============== GLOBAL STATE ==============
WebSocketsClient webSocket;
CRGB leds[NUM_LEDS];
bool isWebSocketConnected = false;
bool recordingActive = false;
bool isPlayingResponse = false;
uint32_t recordingStartTime = 0;
uint8_t audioInputBuffer[MAX_AUDIO_BUFFER_SIZE];
size_t audioBufferIndex = 0;
TaskHandle_t websocketTaskHandle = NULL;
TaskHandle_t ledTaskHandle = NULL;

enum LEDMode { LED_BOOT, LED_IDLE, LED_RECORDING, LED_PROCESSING, LED_AUDIO_REACTIVE, LED_CONNECTED, LED_ERROR };
LEDMode currentLEDMode = LED_BOOT;

// ============== FORWARD DECLARATIONS ==============
void onWebSocketEvent(WStype_t type, uint8_t * payload, size_t length);
void websocketTask(void * parameter);
void ledTask(void * parameter);
void updateLEDs();
bool initI2SMic();
bool initI2SSpeaker();
void handleWebSocketMessage(uint8_t* payload, size_t length);

// ============== SETUP ==============
void setup() {
    Serial.begin(SERIAL_BAUD_RATE);
    delay(1000);
    Serial.println("\n\n=== JellyBerry Conversational AI Device ===");
    Serial.println("Initializing firmware...");

    // Initialize LED strip
    FastLED.addLeds<LED_CHIPSET, LED_DATA_PIN, LED_COLOR_ORDER>(leds, NUM_LEDS);
    FastLED.setBrightness(LED_BRIGHTNESS);
    FastLED.clear();
    fill_solid(leds, NUM_LEDS, CHSV(160, 255, 100));
    FastLED.show();
    Serial.println("✓ LEDs initialized");

    // Initialize I2S audio
    if (!initI2SMic()) {
        Serial.println("✗ Microphone init failed");
        return;
    }
    Serial.println("✓ Microphone initialized");

    if (!initI2SSpeaker()) {
        Serial.println("✗ Speaker init failed");
        return;
    }
    Serial.println("✓ Speaker initialized");

    // Initialize touch pads
    pinMode(TOUCH_PAD_START_PIN, INPUT);
    pinMode(TOUCH_PAD_STOP_PIN, INPUT);
    Serial.println("✓ Touch pads initialized");

    // Connect WiFi
    WiFi.mode(WIFI_STA);
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 20) {
        delay(500);
        Serial.print(".");
        attempts++;
    }
    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\n✓ WiFi connected");
        Serial.printf("IP: %s\n", WiFi.localIP().toString().c_str());
    } else {
        Serial.println("\n✗ WiFi connection failed");
        currentLEDMode = LED_ERROR;
        return;
    }

    // Initialize WebSocket
    webSocket.begin(GEMINI_WS_HOST, GEMINI_WS_PORT, "/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent?key=" + String(GEMINI_API_KEY));
    webSocket.onEvent(onWebSocketEvent);
    webSocket.setReconnectInterval(WS_RECONNECT_INTERVAL);
    Serial.println("✓ WebSocket initialized");

    // Start FreeRTOS tasks
    xTaskCreatePinnedToCore(websocketTask, "WebSocket", 8192, NULL, 1, &websocketTaskHandle, CORE_1);
    xTaskCreatePinnedToCore(ledTask, "LEDs", 4096, NULL, 0, &ledTaskHandle, CORE_0);
    Serial.println("✓ Tasks created on dual cores");

    currentLEDMode = LED_IDLE;
    Serial.println("=== Initialization Complete ===");
}

// ============== MAIN LOOP ==============
void loop() {
    // Poll touch pads
    if (digitalRead(TOUCH_PAD_START_PIN) == HIGH && !recordingActive) {
        recordingActive = true;
        recordingStartTime = millis();
        audioBufferIndex = 0;
        currentLEDMode = LED_RECORDING;
        Serial.println("Recording started...");
    }

    if (digitalRead(TOUCH_PAD_STOP_PIN) == HIGH && recordingActive) {
        recordingActive = false;
        currentLEDMode = LED_PROCESSING;
        uint32_t duration = millis() - recordingStartTime;
        Serial.printf("Recording stopped - Duration: %dms\n", duration);
    }

    // Read microphone when recording
    if (recordingActive && audioBufferIndex < MAX_AUDIO_BUFFER_SIZE) {
        size_t bytes_read = 0;
        if (i2s_read(I2S_NUM_0, &audioInputBuffer[audioBufferIndex], 512, &bytes_read, 10) == ESP_OK) {
            audioBufferIndex += bytes_read;
        }
    }

    delay(10);
}

// ============== I2S INITIALIZATION ==============
bool initI2SMic() {
    i2s_config_t i2s_config = {
        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
        .sample_rate = AUDIO_SAMPLE_RATE,
        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = 8,
        .dma_buf_len = 1024,
        .use_apll = false,
        .tx_desc_auto_clear = false,
        .fixed_mclk = 0
    };

    if (i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL) != ESP_OK) return false;

    i2s_pin_config_t pin_config = {
        .bck_io_num = I2S_MIC_SCK_PIN,
        .ws_io_num = I2S_MIC_WS_PIN,
        .data_out_num = I2S_PIN_NO_CHANGE,
        .data_in_num = I2S_MIC_SD_PIN
    };

    return i2s_set_pin(I2S_NUM_0, &pin_config) == ESP_OK;
}

bool initI2SSpeaker() {
    i2s_config_t i2s_config = {
        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),
        .sample_rate = AUDIO_SAMPLE_RATE,
        .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT,
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = 8,
        .dma_buf_len = 1024,
        .use_apll = false,
        .tx_desc_auto_clear = true,
        .fixed_mclk = 0
    };

    if (i2s_driver_install(I2S_NUM_1, &i2s_config, 0, NULL) != ESP_OK) return false;

    i2s_pin_config_t pin_config = {
        .bck_io_num = I2S_SPEAKER_BCLK_PIN,
        .ws_io_num = I2S_SPEAKER_LRC_PIN,
        .data_out_num = I2S_SPEAKER_DIN_PIN,
        .data_in_num = I2S_PIN_NO_CHANGE
    };

    return i2s_set_pin(I2S_NUM_1, &pin_config) == ESP_OK;
}

// ============== WEBSOCKET HANDLERS ==============
void onWebSocketEvent(WStype_t type, uint8_t * payload, size_t length) {
    switch(type) {
        case WStype_CONNECTED:
            Serial.println("WebSocket Connected to Gemini!");
            isWebSocketConnected = true;
            currentLEDMode = LED_CONNECTED;
            break;
        case WStype_TEXT:
            handleWebSocketMessage(payload, length);
            break;
        case WStype_DISCONNECTED:
            Serial.println("WebSocket Disconnected");
            isWebSocketConnected = false;
            currentLEDMode = LED_ERROR;
            break;
        case WStype_ERROR:
            Serial.println("WebSocket Error");
            currentLEDMode = LED_ERROR;
            break;
        default:
            break;
    }
}

void handleWebSocketMessage(uint8_t* payload, size_t length) {
    JsonDocument doc;
    DeserializationError error = deserializeJson(doc, payload, length);
    if (error) {
        Serial.printf("JSON parse error: %s\n", error.c_str());
        return;
    }
    // Process response - will expand with actual Gemini handling
    if (doc["candidates"].is<JsonArray>()) {
        currentLEDMode = LED_AUDIO_REACTIVE;
        Serial.println("Received Gemini response");
    }
}

// ============== LED CONTROLLER ==============
void updateLEDs() {
    static uint8_t hue = 0;
    static uint8_t brightness = 100;

    switch(currentLEDMode) {
        case LED_BOOT:
            brightness = 100 + 50 * sin(millis() / 500.0);
            fill_solid(leds, NUM_LEDS, CHSV(160, 255, brightness));
            break;
        case LED_IDLE:
            brightness = 50 + 30 * sin(millis() / 2000.0);
            fill_solid(leds, NUM_LEDS, CHSV(160, 200, brightness));
            break;
        case LED_RECORDING:
            brightness = 100 + 100 * abs(sin(millis() / 300.0));
            fill_solid(leds, NUM_LEDS, CHSV(0, 255, brightness));
            break;
        case LED_PROCESSING:
            hue = (millis() / 10) % 256;
            for (int i = 0; i < NUM_LEDS; i++) {
                leds[i] = CHSV(hue + (i * 2), 255, 255);
            }
            break;
        case LED_AUDIO_REACTIVE:
            brightness = 100 + 50 * sin(millis() / 100.0);
            fill_solid(leds, NUM_LEDS, CHSV(96, 200, brightness));
            break;
        case LED_CONNECTED:
            fill_solid(leds, NUM_LEDS, CHSV(128, 255, LED_BRIGHTNESS));
            break;
        case LED_ERROR:
            brightness = (millis() / 200) % 2 ? 255 : 50;
            fill_solid(leds, NUM_LEDS, CHSV(0, 255, brightness));
            break;
    }
}

// ============== FREERTOS TASKS ==============
void websocketTask(void * parameter) {
    while(1) {
        webSocket.loop();
        vTaskDelay(10 / portTICK_PERIOD_MS);
    }
}

void ledTask(void * parameter) {
    while(1) {
        updateLEDs();
        FastLED.show();
        vTaskDelay(50 / portTICK_PERIOD_MS);
    }
}